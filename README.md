
/*
const myBox = box()
const myBoundBox = myBox()
const myBoundBox(() => { 'in mybox bound in parent' })

myBox(() => {'bind then run'})


*/


/*


Our data ontology scientists 

The NPI ['new()' Programing Interface] (aka API, our data )
@newjs
class Class {}

box(fn)
bind = box(ClassA, ProvA, ClassB, ProvA, [ClassC, ProvC, ])

bind(() => 1) === 1

bound = bind()
bound(() => 1) === 1

makeBoundCb = box(A, B)()()(cb)
makeBoundCb = bound()(cb)
makeBoundCb = bind()()(cb)

@newjs
class A {}
class B {}
A.Static = 100
B.Static = 1
result = box(A, B)()()(() => A.Static)() === 1

// You can TOTALLY do this. it's supported and documented (kinda)!!!
//  However, you should NEVER do this! EVER!! Why?
//  Just look at all those FU$#@&$ parenthesis!!
//  Even I dont understand what it's doing, and I wrote the damn thing!!
//  SO NEVER TRY THIS AT HOME!!
//  Only EXPERTS, with years of training, should attempt such transmutations
//       YOU HAVE BEEN WARNED!!!
//  (Actually, I do understand. I've not only tried this, 
//  but have actually done this 1000's of times.. at home on my laptop.
//  Because I'm an export... I mean expert)





The NBI ['new()' Binary Interface]
box.on()  // turns newjs on, like only a box could *snicker*
box.off() // turns newjs off, like only a box could *sad face*

// a handy phrase to remember the NBI, so as not to have
// to lookup and refer to the docs.
"Dan-ya Sawn!!! Bohx Ohn! Bohx Off!"

// wellll.. you can also do this
box.on(Class) === 1 === true === new-newjs
box.off(Class) === 0 === false === new-oldjs (... or old-newjs ... hmm.....)

box.on(Class) === 1 === true === new-newjs
box.off(Class) === 0 === false === new-oldjs (... or old-newjs ... hmm.....)


And here, this is how we can spread the box wiiiiiide open, and go
REALly, relly deep

box(A,B,C,D,E,F,G, () => {
	box(() => {
		box(() => {
			console.log('toes curling!!')
		})
	})
})


finally, after decades of represhing, new()'s FULL POTENTIAL HAS BEEN

	UNLEASHED upon, Further the potential ALSO been COMPLETELTY UNLOCKED
	and removed from its Shackles!!

	New-newjs: Fully unleashes and unlocks the full and complete potential
	like its never been unlocked AND unleashed before





no one was left unturned
no zero was left turned (nor right turned.. these guys were thorough!)


// The Question
// Why isn't new() the ULTIMATE FACTORY OF ALL TIME ???

!!! 
		THE ALL NEW, 
	NEW AND IMPROVED
			new()
!!!
							new-newjs
			Making the old new() the new new()
			  proving the old addage, whats old is new

						Contextually Hieararchical
							Unified and Integrated
			Dependency Inection, Patching, and Mocking

							!!! ALL IN ONE !!!

  					Using the all new new()


				Dependency Injection
								with
				!!! NO STRINGS ATTACHED !!!
  						LITERALLY !!!!

				Patching
					"We don't need no stickin' patches!"
					  Wellll, sometimes ya just do
				
				Mocking
				   Total, utter, "NEe NEr nee nER NEeee neeer"

	
// E = mc^2 "I am become death (of javascript)"
class E {power() {return 'of the universe'}}
class McSqrd {power() {return 'beyond imagination'}}
box(E, McSqrd)(() => (new E()).power() === 'beyond imagination')
box(E, McSqrd)(() => true === (new E() instanceof E))
box(E, McSqrd)(() => true === (new E() instanceof McSqrd))

// Alternate Universe
box(E, {power() {return 'a mockery of Einstein'}})(() => {
	const e = new E()
	e.power() === 'a mockery of Eintstein'
	true === (e instanceof E)
})

//box(Class, Impl)(() => new Class())
*/

//@newjs


// try to make tests and mocks with newjs and eldc, maybe even mocking and injecting
// themselves etc.... absolute insanity as much as possible..
// then story of scientists pushing to the edge, marketting saying "no one will EVER need
// that kind of control over context .. not even close",
// "support screaming of the abuse it will create and resulting cost of calls"
// "the test lab blowing up, and chairman and ceo over funds"

//..... but had to keep going

//..... and then a "sales" guy thought
//..... we shoudl have a 'lodash' hosting company
//..... and they would import '', and then we would
//..... run for them


// PERFORMANCE??
// it actually makes javascript run faster............
// just kidding. But seriously though, the overhead
// is soooo low (like 1% when new()ing) it should
// really be called "underhead", and boy let us tell ya
// new-newjs has like a ridicoulosu amount of underhead